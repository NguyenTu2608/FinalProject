import React, { useState, useEffect, useRef } from "react";
import GameManager from "./GameManager";
import apiClient from "../Services/apiConfig";
import websocketService from "../Services/webSocketServices";
import { getCurrentUser } from "../Services/userServices";
import { toast } from "react-toastify";

// ·∫¢nh qu√¢n c·ªù
const pieceImages = {
  r: "/Assets/red-rook.png",
  n: "/Assets/red-knight.png",
  b: "/Assets/red-bishop.png",
  a: "/Assets/red-advisor.png",
  k: "/Assets/red-king.png",
  c: "/Assets/red-cannon.png",
  p: "/Assets/red-pawn.png",
  R: "/Assets/black-rook.png",
  N: "/Assets/black-knight.png",
  B: "/Assets/black-bishop.png",
  A: "/Assets/black-advisor.png",
  K: "/Assets/black-king.png",
  C: "/Assets/black-cannon.png",
  P: "/Assets/black-pawn.png",
};
// B√†n c·ªù kh·ªüi t·∫°o
const initialBoard = [
  ["r", "n", "b", "a", "k", "a", "b", "n", "r"],
  ["", "", "", "", "", "", "", "", ""],
  ["", "c", "", "", "", "", "", "c", ""],
  ["p", "", "p", "", "p", "", "p", "", "p"],
  ["", "", "", "", "", "", "", "", ""],
  ["", "", "", "", "", "", "", "", ""],
  ["P", "", "P", "", "P", "", "P", "", "P"],
  ["", "C", "", "", "", "", "", "C", ""],
  ["", "", "", "", "", "", "", "", ""],
  ["R", "N", "B", "A", "K", "A", "B", "N", "R"],
];

const Chessboard = ({ gameId, playerBlack, playerRed, setPlayerBlack, setPlayerRed, gameMode, username, nameGame }) => {
  const [board, setBoard] = useState(initialBoard);
  const gameManager = new GameManager(board);
  const [selectedPiece, setSelectedPiece] = useState(null);
  const [validMoves, setValidMoves] = useState([]);
  const [moveHistory, setMoveHistory] = useState([]);
  const [currentPlayer, setCurrentPlayer] = useState("black"); // 'red' ho·∫∑c 'black'
  const [errorMessage, setErrorMessage] = useState(""); // Th√¥ng b√°o l·ªói
  const [gameOver, setGameOver] = useState(false);
  const [winner, setWinner] = useState(null);
  const [timeLeftRed, setTimeLeftRed] = useState(900); // 15 ph√∫t = 900 gi√¢y
  const [timeLeftBlack, setTimeLeftBlack] = useState(900);
  const [timerActive, setTimerActive] = useState(false);
  const [readyStatus, setReadyStatus] = useState({ black: false, red: false });
  const [gameStarted, setGameStarted] = useState(false);
  const [surrenderPlayer, setSurrenderPlayer] = useState(null); // Th√™m state m·ªõi
  const [isWaitingForOpponent, setIsWaitingForOpponent] = useState(false);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [userData, setUserData] = useState(null);
  const [lastMove, setLastMove] = useState(null);
  const playerType = username === playerRed ? 'red' : username === playerBlack ? 'black' : null;
  const isReversed = playerType === 'red';
  const getDisplayCoord = (row, col, isReversed) => {
    return isReversed ? [9 - row, col] : [row, col];
  };

  useEffect(() => {
    // G·ªçi API ƒë·ªÉ l·∫•y th√¥ng tin ng∆∞·ªùi d√πng t·ª´ token
    const fetchUserData = async () => {
      try {
        const data = await getCurrentUser(); // S·ª≠ d·ª•ng h√†m getCurrentUser t·ª´ userService
        setUserData(data); // C·∫≠p nh·∫≠t state v·ªõi th√¥ng tin ng∆∞·ªùi d√πng
      } catch (error) {
        console.error('L·ªói khi l·∫•y th√¥ng tin ng∆∞·ªùi d√πng:', error);
      }
    };

    fetchUserData(); // G·ªçi h√†m khi component ƒë∆∞·ª£c render
  }, []); // G·ªçi 1 l·∫ßn khi component ƒë∆∞·ª£c render

  useEffect(() => {
    let interval;
    if (timerActive && gameStarted && currentPlayer && !gameOver) {
      interval = setInterval(() => {
        if (currentPlayer === "red") {
          setTimeLeftRed((prev) => (prev > 0 ? prev - 1 : 0));
        } else {
          setTimeLeftBlack((prev) => (prev > 0 ? prev - 1 : 0));
        }
      }, 1000);
    }

    return () => clearInterval(interval);
  }, [timerActive, gameStarted, gameOver, currentPlayer]);

  useEffect(() => {
    const handleBeforeUnload = () => {
      if (gameMode === "online") {
        websocketService.sendLeaveRequest(gameId, username); // G·ª≠i s·ª± ki·ªán r·ªùi ƒëi cho server
        
      }
    };

    window.addEventListener("beforeunload", handleBeforeUnload);
    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
    };
  }, [gameId, username, gameMode]);

  useEffect(() => {
    if (gameMode !== "online") return;

    console.log("üì° K·∫øt n·ªëi WebSocket ƒë·ªÉ nh·∫≠n n∆∞·ªõc ƒëi...");

    if (!websocketService.isConnected) {
      console.warn("‚ö† WebSocket ch∆∞a k·∫øt n·ªëi, th·ª≠ k·∫øt n·ªëi l·∫°i...");
      websocketService.connect(() => {
        console.log("üîÑ ƒê√£ k·∫øt n·ªëi l·∫°i WebSocket!");
        websocketService.subscribeToGame(gameId, handleGameMove);
        websocketService.subscribeToGame(gameId, handleCheckNotification);
        websocketService.subscribeToGame(gameId, handleSurrenderNotification);
        websocketService.subscribeToGame(gameId, handlePlayerRefreshNotification); // üëà th√™m d√≤ng n√†y
      });
    } else {
      websocketService.subscribeToGame(gameId, handleGameMove);
      websocketService.subscribeToGame(gameId, handleCheckNotification);
      websocketService.subscribeToGame(gameId, handleSurrenderNotification);
      websocketService.subscribeToGame(gameId, handlePlayerRefreshNotification); // üëà th√™m d√≤ng n√†y
    }

    return () => {
      websocketService.unsubscribeFromGame(gameId);
      websocketService.unsubscribeFromChat(gameId);
    };
  }, [gameId, gameMode]);

  useEffect(() => {
    // Khi trang t·∫£i, thay ƒë·ªïi l·ªãch s·ª≠ tr√¨nh duy·ªát ƒë·ªÉ ngƒÉn ng∆∞·ªùi d√πng quay l·∫°i trang tr∆∞·ªõc
    window.history.pushState(null, document.title, window.location.href);

    // L·∫Øng nghe s·ª± ki·ªán khi ng∆∞·ªùi d√πng nh·∫•n n√∫t "quay l·∫°i" (back)
    window.onpopstate = function (event) {
      // Chuy·ªÉn h∆∞·ªõng l·∫°i trang hi·ªán t·∫°i n·∫øu ng∆∞·ªùi d√πng nh·∫•n n√∫t back
      window.history.go(1);  // ƒêi·ªÅu h∆∞·ªõng ng∆∞·ªùi d√πng t·ªõi trang hi·ªán t·∫°i
    };

    // D·ªçn d·∫πp khi component b·ªã unmount
    return () => {
      window.onpopstate = null;
    };
  }, []);

  useEffect(() => {
    if (gameMode === "online") {
      websocketService.setupRefreshOnUnload(gameId, username);
    }

    return () => {
      websocketService.disconnect(); // s·∫Ω remove listener lu√¥n
    };
  }, [gameMode, gameId, username]);

  //nhan message san sang`
  useEffect(() => {
    if (gameMode !== "online") return;
    const handleReadyMessage = (messageReady) => {
      let response;

      // Ki·ªÉm tra n·∫øu messageReady.body t·ªìn t·∫°i v√† l√† chu·ªói JSON
      if (messageReady.body && typeof messageReady.body === "string") {
        try {
          response = JSON.parse(messageReady.body);
        } catch (error) {
          console.error("‚ùå L·ªñI: Kh√¥ng th·ªÉ parse JSON t·ª´ WebSocket!", error);
          return;
        }
      } else if (typeof messageReady === "object") {
        response = messageReady; // N·∫øu ƒë√£ l√† object th√¨ s·ª≠ d·ª•ng lu√¥n
      } else {
        console.error("‚ùå L·ªñI: D·ªØ li·ªáu WebSocket kh√¥ng h·ª£p l·ªá!", messageReady);
        return;
      }

      console.log("üì© Nh·∫≠n tin nh·∫Øn:", response);

      if (response.type === "readyStatus") {
        setReadyStatus({
          black: response.blackReady,
          red: response.redReady,
        });
      } else if (response.type === "gameStart") {
        setGameStarted(true);
        setTimerActive(true);
      }
    };

    websocketService.subscribeToGame(gameId, handleReadyMessage);

    return () => {
      websocketService.unsubscribeFromGame(gameId);
    };

  }, [gameId, gameMode]);

  useEffect(() => {
    if (gameMode !== "online") return;

    const handlePlayerLeft = (message) => {
      let response;

      // üß© Parse d·ªØ li·ªáu t·ª´ WebSocket
      if (message.body && typeof message.body === "string") {
        try {
          response = JSON.parse(message.body);
        } catch (error) {
          console.error("‚ùå L·ªñI: Kh√¥ng th·ªÉ parse JSON!", error);
          return;
        }
      } else if (typeof message === "object") {
        response = message;
      } else {
        console.error("‚ùå L·ªñI: D·ªØ li·ªáu WebSocket kh√¥ng h·ª£p l·ªá!", message);
        return;
      }

      // ‚úÖ X·ª≠ l√Ω khi m·ªôt ng∆∞·ªùi ch∆°i r·ªùi
      if (response.type === "playerLeft") {
        setPlayerBlack(response.playerBlack || null);
        setPlayerRed(response.playerRed || null);

        // üéØ N·∫øu c√≥ winner (do ƒë·ªëi th·ªß tho√°t) th√¨ x·ª≠ l√Ω k·∫øt th√∫c v√°n
        if (response.winner && response.reason === "opponentLeft") {
          const winnerColor = response.winner;

          setGameOver(true);
          setWinner(winnerColor);
          setTimerActive(false);

          return; // ‚ùó D·ª´ng l·∫°i, kh√¥ng c·∫ßn reset to√†n b·ªô nh∆∞ d∆∞·ªõi
        }

        // üîÅ N·∫øu m·ªôt trong hai ng∆∞·ªùi r·ªùi khi ch∆∞a b·∫Øt ƒë·∫ßu => reset tr·∫°ng th√°i ch·ªù
        if (!response.playerBlack || !response.playerRed) {
          console.log("üîÑ M·ªôt ng∆∞·ªùi ƒë√£ r·ªùi ph√≤ng, reset b√†n c·ªù v√† tr·∫°ng th√°i game.");
          setBoard(initialBoard);
          setMoveHistory([]);
          setCurrentPlayer("black");
          setGameStarted(false);
          setTimerActive(false);
          setReadyStatus({ black: false, red: false });
          setGameOver(false);
          setWinner(null);
          setLastMove(null);
          setSelectedPiece(null);
          setValidMoves([]);
          setErrorMessage("");
        }
      }
    };

    websocketService.subscribeToGame(gameId, handlePlayerLeft);
    return () => {
      websocketService.unsubscribeFromGame(gameId);
    };
  }, [gameId, gameMode, currentPlayer]);

  // Gi·ªØ l·∫°i trang hi·ªán t·∫°i trong l·ªãch s·ª≠ v√† ngƒÉn kh√¥ng cho ng∆∞·ªùi d√πng quay l·∫°i trang tr∆∞·ªõc
  window.history.pushState(null, document.title, window.location.href);

  // NgƒÉn ch·∫∑n h√†nh ƒë·ªông quay l·∫°i
  window.onpopstate = function (event) {
    window.history.go(1); // ƒêi·ªÅu h∆∞·ªõng t·ªõi trang hi·ªán t·∫°i n·∫øu ng∆∞·ªùi d√πng nh·∫•n "Back"
  };

  const handlePlayerRefreshNotification = (payload) => {
    if (payload.type === "refresh") {
      toast.info(payload.message); // Hi·ªÉn th·ªã th√¥ng b√°o v·ªÅ vi·ªác refresh
      // N·∫øu game ch∆∞a b·∫Øt ƒë·∫ßu, reset l·∫°i tr·∫°ng th√°i
      setReadyStatus({ black: false, red: false });
      setGameStarted(false);
    }

    if (payload.type === "player-refresh-during-game") {
      // Th√¥ng b√°o ng∆∞·ªùi ch∆°i c√≤n l·∫°i th·∫Øng
      toast.success(payload.message); // Th√¥ng b√°o ng∆∞·ªùi c√≤n l·∫°i th·∫Øng

      // C·∫≠p nh·∫≠t tr·∫°ng th√°i game khi ng∆∞·ªùi ch∆°i ƒë√£ refresh gi·ªØa tr·∫≠n
      setReadyStatus({ black: false, red: false });
      setWinner(payload.winner);
      setGameOver(true);  // ƒê√°nh d·∫•u game k·∫øt th√∫c
      setBoard(initialBoard);  // üü¢ Reset b√†n c·ªù v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
      setMoveHistory([]);  // X√≥a l·ªãch s·ª≠ c√°c n∆∞·ªõc ƒëi
      setSelectedPiece(null);  // Deselect qu√¢n c·ªù ƒë√£ ch·ªçn
      setValidMoves([]);  // X√≥a c√°c n∆∞·ªõc ƒëi h·ª£p l·ªá
      setErrorMessage("");  // X√≥a th√¥ng b√°o l·ªói

    }

  };

  const handleSurrenderNotification = (message) => {
    if (!message || message.type !== "surrender") return;

    setSurrenderPlayer(message.surrenderPlayer); // L∆∞u ng∆∞·ªùi ƒë·∫ßu h√†ng v√†o state
    setWinner(message.winner); // L∆∞u ng∆∞·ªùi th·∫Øng v√†o state
    setGameOver(true);
    setIsWaitingForOpponent(true);
  };

  const resetGameOnline = () => {
    setBoard(initialBoard);
    setGameStarted(false);
    setIsWaitingForOpponent(true);
    setMoveHistory([]);
    setCurrentPlayer(currentPlayer);
    setSelectedPiece(null);
    setValidMoves([]);
    setErrorMessage("");
    setGameOver(false);
    setWinner(null);
    setLastMove(null)
    setTimeLeftRed(900);
    setTimeLeftBlack(900);
    setTimerActive(true);
    setReadyStatus({ black: false, red: false });
  };

  //truyen san sang len server
  const sendReadyStatus = () => {
    websocketService.sendReadyRequest(gameId, username);
  };

  //nhan nuoc di tu sever
  const handleGameMove = (message) => {
    if (!message || message.type !== "gameMove") return;

    const { from, to, movedPiece, currentTurn } = message;

    // üîπ Ki·ªÉm tra d·ªØ li·ªáu h·ª£p l·ªá
    if (!from || !to || typeof movedPiece !== "string") {
      console.warn("‚ö† L·ªói: D·ªØ li·ªáu n∆∞·ªõc ƒëi kh√¥ng h·ª£p l·ªá!", message);
      return;
    }

    if (from.row < 0 || from.row >= 10 || from.col < 0 || from.col >= 9 ||
      to.row < 0 || to.row >= 10 || to.col < 0 || to.col >= 9) {
      console.warn("‚ö† L·ªói: N∆∞·ªõc ƒëi ngo√†i ph·∫°m vi b√†n c·ªù!", from, to);
      return;
    }

    setBoard((prevBoard) => {
      const updatedBoard = prevBoard.map(row => [...row]); // üî• Copy m·∫£ng 2D

      if (!updatedBoard[from.row][from.col]) {
        // console.warn("‚ö† Kh√¥ng t√¨m th·∫•y qu√¢n c·ªù ·ªü v·ªã tr√≠ c≈©:", from);
        return prevBoard;
      }

      setLastMove({ from, to });
      // ‚úÖ C·∫≠p nh·∫≠t v·ªã tr√≠ qu√¢n c·ªù m·ªõi
      updatedBoard[to.row][to.col] = movedPiece;
      updatedBoard[from.row][from.col] = "";

      return updatedBoard;
    });

    // ‚úÖ C·∫≠p nh·∫≠t l·ªãch s·ª≠ n∆∞·ªõc ƒëi
    setMoveHistory((prevHistory) => [...prevHistory, message]);


    // ‚úÖ C·∫≠p nh·∫≠t l∆∞·ª£t ch∆°i ti·∫øp theo
    if (currentTurn) {
      setCurrentPlayer(currentTurn);
      setTimerActive(true);
    } else {
      console.warn("‚ö† Kh√¥ng nh·∫≠n ƒë∆∞·ª£c currentTurn t·ª´ WebSocket!");
    }
  };

  const handleCheckNotification = (message) => {
    if (!message || message.type !== "checkNotification") return;

    console.log("üî• Nh·∫≠n th√¥ng b√°o chi·∫øu t·ª´ server:", message);

    if (message.isCheckmate) {
      setErrorMessage(`üèÜ ${message.player} ƒë√£ chi·∫øu b√≠! Tr√≤ ch∆°i k·∫øt th√∫c.`);
      setGameOver(true);
      setIsWaitingForOpponent(true);
    } else {
      setErrorMessage(`üî• ${message.player} ƒë√£ chi·∫øu t∆∞·ªõng!`);
    }
  };

  // H√†m ƒë·ªãnh d·∫°ng th·ªùi gian
  const formatTime = (seconds) => {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  };

  //dau hang
  const handleSurrender = (player) => {
    if (gameOver) return; // N·∫øu game ƒë√£ k·∫øt th√∫c, kh√¥ng c·∫ßn x·ª≠ l√Ω

    console.log(`üè≥Ô∏è ${player} g·ª≠i y√™u c·∫ßu ƒë·∫ßu h√†ng`);

    if (gameMode === "online") {
      websocketService.sendSurrenderNotification(gameId, player); // G·ª≠i y√™u c·∫ßu ƒë·∫ßu h√†ng l√™n server
    } else {
      const winner = player === "red" ? "black" : "red"; // X√°c ƒë·ªãnh ng∆∞·ªùi th·∫Øng
      setErrorMessage(`${winner === "red" ? "ƒê·ªè" : "ƒêen"} th·∫Øng! ${player === "red" ? "ƒê·ªè" : "ƒêen"} ƒë√£ ƒë·∫ßu h√†ng.`);
      setWinner(winner);
      setGameOver(true);
    }
  };

  if (!gameStarted) {
    return (
      <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50">
        <div className="bg-[#f7e3c4] p-8 rounded-full text-center animate-fade-in max-w-md w-full">
          {/* Ch·ªâ hi·ªÉn th·ªã t√™n ph√≤ng n·∫øu l√† ch·∫ø ƒë·ªô online */}
          {gameMode !== "practice" && <h2 className="text-2xl font-semibold mb-4"> T√™n ph√≤ng : {nameGame}</h2>}

          {gameMode === "practice" ? (
            <button
              onClick={() => {
                setGameStarted(true);
                setTimerActive(true);
              }}
              className="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-8 rounded-full text-xl shadow-lg hover:shadow-xl"
            >
              B·∫•m ƒë·ªÉ b·∫Øt ƒë·∫ßu
            </button>
          ) : (
            <div>
              {playerBlack && playerRed ? (
                <>
                  <div className="flex justify-between mb-4 text-lg font-semibold">
                    <div className="text-black">
                      {playerBlack} {username === playerBlack && "(B·∫°n)"}
                      {readyStatus["black"] && (
                        <p className="text-green-500 text-sm">ƒê√£ S·∫µn S√†ng</p>
                      )}
                    </div>
                    <div className="text-red-600">
                      {playerRed} {username === playerRed && "(B·∫°n)"}
                      {readyStatus["red"] && (
                        <p className="text-green-500 text-sm">ƒê√£ S·∫µn S√†ng</p>
                      )}
                    </div>
                  </div>
                  <p className="mb-4 text-lg font-semibold text-green-600">
                    ƒê√£ ƒë·ªß ng∆∞·ªùi ch∆°i ! H√£y s·∫µn s√†ng.
                  </p>
                  <button
                    onClick={sendReadyStatus}
                    className="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-8 rounded-full text-xl shadow-lg hover:shadow-xl"
                  >
                    {readyStatus[username === playerBlack ? "black" : "red"]
                      ? "ƒê√£ S·∫µn S√†ng"
                      : "S·∫µn S√†ng"}
                  </button>
                </>
              ) : (
                <p className="mb-4 text-lg font-semibold">
                  ƒêang ch·ªù ng∆∞·ªùi ch∆°i kh√°c...
                </p>
              )}
            </div>
          )}
        </div>
      </div>
    );
  }

  const handleClick = async (row, col) => {
    console.log("üìç Nh·∫•n v√†o √¥:", row, col, " | Ng∆∞·ªùi ch∆°i hi·ªán t·∫°i:", currentPlayer);

    if (gameMode === "online") {
      if (!username) {
        console.warn("‚ö† Kh√¥ng l·∫•y ƒë∆∞·ª£c username! Ki·ªÉm tra token ƒëƒÉng nh·∫≠p.");
        return;
      }

      if (!playerBlack || !playerRed) {
        console.warn("‚ö† Ch∆∞a c√≥ ƒë·ªß hai ng∆∞·ªùi ch∆°i!");
        return;
      }

      if (currentPlayer !== "black" && currentPlayer !== "red") {
        console.warn("‚ö† L∆∞·ª£t ch∆°i kh√¥ng h·ª£p l·ªá:", currentPlayer);
        return;
      }

      // üî• Ki·ªÉm tra n·∫øu kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa ng∆∞·ªùi ch∆°i hi·ªán t·∫°i
      const isNotTurn =
        (currentPlayer === "black" && username !== playerBlack) ||
        (currentPlayer === "red" && username !== playerRed);

      if (isNotTurn) {
        console.log("üö´ Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n! Ng∆∞·ªùi ch∆°i hi·ªán t·∫°i:", currentPlayer, "| B·∫°n:", username);
        setErrorMessage("Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n!");
        return;
      }
    }
    const piece = board[row][col];
    const isRedPiece = piece && piece === piece.toLowerCase(); // Qu√¢n ƒë·ªè l√† ch·ªØ th∆∞·ªùng
    const isBlackPiece = piece && piece === piece.toUpperCase(); // Qu√¢n ƒëen l√† ch·ªØ hoa
    if (selectedPiece) {
      if (validMoves.some(([r, c]) => r === row && c === col)) {
        if (gameManager.isMoveCausingCheck(selectedPiece.row, selectedPiece.col, row, col, currentPlayer === "red")) {
          setErrorMessage("N∆∞·ªõc ƒëi n√†y s·∫Ω g√¢y chi·∫øu t∆∞·ªõng!");
          return; // Kh√¥ng th·ª±c hi·ªán n∆∞·ªõc ƒëi
        }
        const moveFrom = { row: selectedPiece.row, col: selectedPiece.col };
        // Move the piece
        const newBoard = gameManager.movePiece(
          selectedPiece.row,
          selectedPiece.col,
          row,
          col,
          currentPlayer
        );
        const move = {
          gameId,
          from: { row: selectedPiece.row, col: selectedPiece.col },
          to: { row, col },
          piece: selectedPiece.piece,
          player: currentPlayer,
        };
        // üì° G·ª≠i n∆∞·ªõc ƒëi l√™n server n·∫øu l√† ch·∫ø ƒë·ªô online
        if (gameMode === "online") {
          console.log("üì° G·ª≠i n∆∞·ªõc ƒëi qua WebSocket:", move);
          websocketService.sendMove(gameId, move);
        } else {
          try {
            await apiClient.post(`/games/${gameId}/moves`, move);
            console.log("Move successfully sent to server");
          } catch (error) {
            console.error("Failed to send move to server", error);
          }
        }
        console.log("N∆∞·ªõc ƒëi m·ªõi:", move); // Ki·ªÉm tra log

        setLastMove({
          from: moveFrom,
          to: { row, col }
        });

        setMoveHistory(prevHistory => [...prevHistory, move]);
        // X√°c ƒë·ªãnh l∆∞·ª£t ch∆°i ti·∫øp theo
        const nextPlayer = currentPlayer === "red" ? "black" : "red";

        setBoard([...newBoard]); // Ensure a new state reference

        setSelectedPiece(null);
        setValidMoves([]);
        setErrorMessage("");


        if (gameMode === "online") {
          const opponentIsRed = currentPlayer === "black"; // ƒê·ªëi th·ªß c·ªßa ng∆∞·ªùi v·ª´a ƒëi
          const isCheck = gameManager.isKingInCheck(opponentIsRed);
          const isCheckmate = gameManager.isCheckmate(opponentIsRed);

          if (isCheck || isCheckmate) {
            console.log(isCheckmate ? "üî• Chi·∫øu b√≠ !" : "‚ö† Chi·∫øu t∆∞·ªõng!");
            console.log("üî• G·ª≠i th√¥ng b√°o chi·∫øu:", {
              gameId,
              username,
              isCheck,
              isCheckmate
            });
            // üì® G·ª≠i th√¥ng b√°o qua WebSocket
            websocketService.sendCheckNotification(gameId, username, isCheck, isCheckmate);

            // Hi·ªÉn th·ªã th√¥ng b√°o tr√™n giao di·ªán cho ng∆∞·ªùi ch∆°i hi·ªán t·∫°i
            setErrorMessage(isCheckmate ? "Chi·∫øu b√≠! Tr√≤ ch∆°i k·∫øt th√∫c. " : "Chi·∫øu t∆∞·ªõng!");

            // N·∫øu chi·∫øu b√≠, c√≥ th·ªÉ x·ª≠ l√Ω logic k·∫øt th√∫c game
            if (isCheckmate) {
              setGameOver(true);
              setWinner(currentPlayer);
            }
          }
        }

        // Ch·ªâ ki·ªÉm tra chi·∫øu t∆∞·ªõng trong ch·∫ø ƒë·ªô practice
        if (gameMode === "practice") {
          const newGameManager = new GameManager(newBoard);
          // Ki·ªÉm tra xem b√™n ƒë∆∞·ª£c chuy·ªÉn giao c√≥ b·ªã chi·∫øu b√≠ hay kh√¥ng

          if (newGameManager.isCheckmate(nextPlayer === "red")) {

            setGameOver(true);
            setWinner(nextPlayer);
            setErrorMessage(
              `${nextPlayer === "red" ? "ƒê·ªè" : "ƒêen"} b·ªã chi·∫øu b√≠! Tr√≤ ch∆°i k·∫øt th√∫c.`
            );
            console.log(winner);
          }
          const opponentIsRed = currentPlayer === "black";

          if (gameManager.isKingInCheck(opponentIsRed)) {
            setErrorMessage("Chi·∫øu t∆∞·ªõng!");
            // Ki·ªÉm tra xem c√≥ ph·∫£i l√† chi·∫øu b√≠ hay kh√¥ng
            if (gameManager.isCheckmate(opponentIsRed)) {
              setErrorMessage("Chi·∫øu b√≠! Tr√≤ ch∆°i k·∫øt th√∫c.");
              // C√≥ th·ªÉ th√™m logic k·∫øt th√∫c tr√≤ ch∆°i ·ªü ƒë√¢y
            }
          }
        }
        if (!gameOver) setCurrentPlayer(nextPlayer);
      } else {
        setSelectedPiece(null);
        setValidMoves([]);
        // setErrorMessage("N∆∞·ªõc ƒëi kh√¥ng h·ª£p l·ªá!");
      }
    } else if (piece)
      if ((currentPlayer === "red" && isRedPiece) || (currentPlayer === "black" && isBlackPiece)) {

        const valid = gameManager.getValidMoves(piece, row, col);
        setSelectedPiece({ row, col, piece });
        setValidMoves(valid);
        setErrorMessage(""); // X√≥a th√¥ng b√°o l·ªói
      }
      else {
        // setErrorMessage("Kh√¥ng ph·∫£i l∆∞·ª£t c·ªßa b·∫°n!");
      }
  };

  const restartGamePractice = () => {
    setBoard(initialBoard);
    setCurrentPlayer("black"); // ho·∫∑c ch·ªçn m√†u b·∫°n mu·ªën ƒëi tr∆∞·ªõc
    setSelectedPiece(null);
    setValidMoves([]);
    setErrorMessage("");
    setGameOver(false);
    setWinner(null);
    setLastMove(null)
    setTimeLeftRed(900);
    setTimeLeftBlack(900);
    setTimerActive(true);
  };

  const ProfileCard = ({ timeLeft, isCurrentPlayer, playerType, onSurrender }) => {
    const handleSurrenderClick = () => {
      onSurrender(); // Th·ª±c hi·ªán ƒë·∫ßu h√†ng ngay l·∫≠p t·ª©c
    };
    return (
      <div className={`flex flex-col items-center bg-[#f7e3c4] bg-opacity-80 p-4 rounded-md shadow-lg w-64 text-white 
        ${isCurrentPlayer ? 'ring-4 ring-offset-2 ring-red-500' : ''}`}>
        <div className="relative">
          <img
            src={userData?.avatar || "/Assets/avatarloading"}
            alt="Avatar"
            className="w-24 h-24 rounded-full border-4 border-orange-500"
          />
          <div className="absolute -bottom-3 left-1/2 transform -translate-x-1/2 bg-orange-500 px-4 py-1 rounded-full text-lg font-bold">
            {playerType === 'red' ? 'ƒê·ªè' : 'ƒêen' || "ƒêang ch·ªù..."}
          </div>
        </div>

        <div className="bg-gray-700 text-yellow-300 text-lg font-semibold mt-6 px-6 py-2 rounded-full w-full text-center">
          {playerType === 'red'
            ? playerRed === username ? `${playerRed} (B·∫°n)` : playerRed
            : playerBlack === username ? `${playerBlack} (B·∫°n)` : playerBlack}
        </div>

        <div className={`flex items-center mt-4 px-6 py-2 rounded-full font-bold ${isCurrentPlayer ? 'bg-yellow-500 text-black' : 'bg-gray-700'}`}>
          ‚è≥ {formatTime(timeLeft)}
        </div>

        <button
          onClick={handleSurrenderClick} // ƒê·∫ßu h√†ng ngay l·∫≠p t·ª©c
          disabled={
            gameMode === "online"
              ? !(username === playerRed && playerType === "red") &&
              !(username === playerBlack && playerType === "black")
              : false // üîπ Ch·∫ø ƒë·ªô practice lu√¥n cho ph√©p ƒë·∫ßu h√†ng
          }
          className={`mt-4 ${gameMode === "online"
            ? (username === playerRed && playerType === "red") ||
              (username === playerBlack && playerType === "black")
              ? "bg-red-500 hover:bg-red-600"
              : "bg-gray-500 cursor-not-allowed"
            : "bg-red-500 hover:bg-red-600" // üîπ Lu√¥n b·∫≠t ·ªü ch·∫ø ƒë·ªô practice
            } text-white font-bold py-2 px-4 rounded-full flex items-center`}
        >
          <img src="/Assets/surrender.png" alt="Flag" className="w-5 h-5 mr-2" />
          ƒê·∫ßu h√†ng
        </button>
      </div>
    );
  };

  const boardSize = 500;
  const cellSize = boardSize / 9;

  return (
    <div className="flex justify-center items-center space-x-8">
      {/* ProfileCard */}
      <ProfileCard
        timeLeft={timeLeftBlack}
        isCurrentPlayer={currentPlayer === "black" && !gameOver}
        playerType="black"
        username={username}
        playerRed={playerRed} // üîπ Truy·ªÅn t√™n ng∆∞·ªùi ch∆°i ƒë·ªè
        playerBlack={playerBlack} // üîπ Truy·ªÅn t√™n ng∆∞·ªùi ch∆°i ƒëen
        gameMode={gameMode}
        onSurrender={() => handleSurrender("black")}
      />
      <div className="relative w-[500px] h-[550px] mx-auto">
        <img src="/Assets/chessboard.png" alt="Chessboard" className="w-full h-full" />
        {board.map((row, rowIndex) =>
          row.map((piece, colIndex) => {
            if (!piece) return null;
            const [displayRow, displayCol] = getDisplayCoord(rowIndex, colIndex, isReversed);

            return (
              <img
                key={`${rowIndex}-${colIndex}`}
                src={pieceImages[piece]}
                alt={piece}
                className="absolute w-[45px] h-[45px] transform -translate-x-1/2 -translate-y-1/2 cursor-pointer"
                style={{
                  left: `${displayCol * cellSize + cellSize / 2}px`,
                  top: `${displayRow * cellSize + cellSize / 2}px`,
                }}
                onClick={() => handleClick(rowIndex, colIndex)}
              />
            );
          })
        )}

        {validMoves.map(([row, col]) => {
          const [displayRow, displayCol] = getDisplayCoord(row, col, isReversed);
          return (
            <div
              key={`${row}-${col}`}
              className="absolute w-[45px] h-[45px] bg-green-500 opacity-50 transform -translate-x-1/2 -translate-y-1/2 rounded-full"
              style={{
                left: `${displayCol * cellSize + cellSize / 2}px`,
                top: `${displayRow * cellSize + cellSize / 2}px`,
              }}
              onClick={() => handleClick(row, col)}
            />
          );
        })}

        {lastMove && (
          <>
            {(() => {
              const [fromRow, fromCol] = getDisplayCoord(lastMove.from.row, lastMove.from.col, isReversed);
              const [toRow, toCol] = getDisplayCoord(lastMove.to.row, lastMove.to.col, isReversed);

              return (
                <>
                  {/* ƒêi·ªÉm b·∫Øt ƒë·∫ßu: v√≤ng tr√≤n nh·ªè */}
                  <div
                    className="absolute w-[18px] h-[18px] bg-green-600 opacity-80 transform -translate-x-1/2 -translate-y-1/2 rounded-full pointer-events-none"
                    style={{
                      width: `${cellSize * 0.4}px`,
                      height: `${cellSize * 0.4}px`,
                      left: `${fromCol * cellSize + cellSize / 2}px`,
                      top: `${fromRow * cellSize + cellSize / 2}px`,
                      transform: "translate(-50%, -50%)",
                    }}
                  />

                  {/* ƒêi·ªÉm k·∫øt th√∫c: v√≤ng tr√≤n b·∫±ng qu√¢n c·ªù */}
                  <div
                    className="absolute rounded-full pointer-events-none"
                    style={{
                      width: `${cellSize * 0.8}px`,
                      height: `${cellSize * 0.8}px`,
                      left: `${toCol * cellSize + cellSize / 2}px`,
                      top: `${toRow * cellSize + cellSize / 2}px`,
                      transform: "translate(-50%, -50%)",
                      boxShadow: "0 0 8px 2px #22c55e",
                    }}
                  />
                </>
              );
            })()}
          </>
        )}

        {/* Hi·ªÉn th·ªã th√¥ng b√°o l·ªói */}
        {errorMessage && (
          <div
            className="absolute left-1/2 transform -translate-x-1/2 bg-red-500 text-white p-2 rounded"
            style={{
              top: "100%", // ƒê∆∞a th√¥ng b√°o xu·ªëng d∆∞·ªõi b√†n c·ªù
              marginTop: "10px", // T·∫°o kho·∫£ng c√°ch gi·ªØa b√†n c·ªù v√† th√¥ng b√°o
            }}
          >
            {errorMessage}
          </div>
        )}
        {/* Overlay hi·ªÉn th·ªã khi tr√≤ ch∆°i k·∫øt th√∫c */}
        {gameOver && (
          <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-60">
            <div className="bg-white p-8 rounded-lg shadow-2xl text-center max-w-lg mx-auto transform transition-all duration-300 ease-in-out">
              <h2 className="text-3xl font-semibold mb-6 text-gray-800">Tr√≤ ch∆°i k·∫øt th√∫c!</h2>
              <p className="text-xl mb-6 text-gray-600">
                {gameMode === "online" ? (
                  (winner === "red" && username === playerRed) ||
                    (winner === "black" && username === playerBlack)
                    ? "üéâ B·∫°n ƒë√£ th·∫Øng!"
                    : "üòû B·∫°n ƒë√£ thua!"
                ) : (
                  winner === "red"
                    ? "ƒê·ªè th·∫Øng!"
                    : winner === "black"
                      ? "ƒêen th·∫Øng!"
                      : "Tr·∫≠n ƒë·∫•u kh√¥ng c√≥ k·∫øt qu·∫£!" // Tr∆∞·ªùng h·ª£p kh√¥ng c√≥ ng∆∞·ªùi th·∫Øng, nh∆∞ ƒë·∫ßu h√†ng
                )}
              </p>
              <div className="flex justify-center gap-4">
                {gameMode === "online" ? (
                  gameOver ? (
                    <button
                      onClick={resetGameOnline}
                      className="bg-blue-500 hover:bg-blue-600 text-white py-3 px-6 rounded-md text-lg transition duration-300 ease-in-out transform hover:scale-105"
                    >
                      Ch∆°i l·∫°i
                    </button>
                  ) : (
                    <button
                      className="bg-gray-500 text-white py-3 px-6 rounded-md text-lg cursor-not-allowed"
                      disabled
                    >
                      ƒêang ch·ªù ƒë·ªëi th·ªß...
                    </button>
                  )
                ) : (
                  <button
                    onClick={restartGamePractice}
                    className="bg-green-500 hover:bg-green-600 text-white py-3 px-6 rounded-md text-lg transition duration-300 ease-in-out transform hover:scale-105"
                  >
                    New Game
                  </button>
                )}
              </div>
            </div>
          </div>
        )}

      </div>
      {/* ProfileCard b√™n ph·∫£i (ƒë·ªëi x·ª©ng) */}
      <ProfileCard
        timeLeft={timeLeftRed}
        isCurrentPlayer={currentPlayer === "red" && !gameOver}
        playerType="red"
        username={username}
        playerRed={playerRed}
        playerBlack={playerBlack}
        gameMode={gameMode}
        onSurrender={() => handleSurrender("red")}
      />
    </div>
  );
};

export default Chessboard;
