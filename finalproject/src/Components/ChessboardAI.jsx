import React, { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import { useLocation } from "react-router-dom";
import GameManager from "./GameManager";

const pieceImages = {
  r: "/Assets/red-rook.png",
  n: "/Assets/red-knight.png",
  b: "/Assets/red-bishop.png",
  a: "/Assets/red-advisor.png",
  k: "/Assets/red-king.png",
  c: "/Assets/red-cannon.png",
  p: "/Assets/red-pawn.png",
  R: "/Assets/black-rook.png",
  N: "/Assets/black-knight.png",
  B: "/Assets/black-bishop.png",
  A: "/Assets/black-advisor.png",
  K: "/Assets/black-king.png",
  C: "/Assets/black-cannon.png",
  P: "/Assets/black-pawn.png",
};

const initialBoard = [
  ["r", "n", "b", "a", "k", "a", "b", "n", "r"],
  ["", "", "", "", "", "", "", "", ""],
  ["", "c", "", "", "", "", "", "c", ""],
  ["p", "", "p", "", "p", "", "p", "", "p"],
  ["", "", "", "", "", "", "", "", ""],
  ["", "", "", "", "", "", "", "", ""],
  ["P", "", "P", "", "P", "", "P", "", "P"],
  ["", "C", "", "", "", "", "", "C", ""],
  ["", "", "", "", "", "", "", "", ""],
  ["R", "N", "B", "A", "K", "A", "B", "N", "R"],
];

const ChessboardAI = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const queryParams = new URLSearchParams(location.search);

  const mode = queryParams.get("mode") || "easy";
  const playerColor = queryParams.get("color") || "black";
  const aiColor = playerColor === "black" ? "red" : "black";

  const [board, setBoard] = useState(initialBoard);
  const [selectedPiece, setSelectedPiece] = useState(null);
  const [validMoves, setValidMoves] = useState([]);
  const [errorMessage, setErrorMessage] = useState("");
  const [currentTurn, setCurrentTurn] = useState("black"); // ƒêen ƒëi tr∆∞·ªõc

  const gameManager = new GameManager(board);

  // N·∫øu AI l√† ƒêen, n√≥ s·∫Ω ƒëi tr∆∞·ªõc khi game b·∫Øt ƒë·∫ßu
  useEffect(() => {
    if (currentTurn === aiColor) {
      handleAIMove();
    }
  }, [currentTurn]);

    let aiDifficulty = "";

    const handleAIMove = () => {
        switch(aiDifficulty) {
            case "easy":
                handleAIMoveEasy();
                break;
            case "medium":
                handleAIMoveMedium();
                break;
            case "hard":
                handleAIMoveHard();
                break;
            default:
                handleAIMoveEasy();
        }
    };


  // X·ª≠ l√Ω n∆∞·ªõc ƒëi c·ªßa AI (ch·ªçn ng·∫´u nhi√™n t·ª´ danh s√°ch n∆∞·ªõc h·ª£p l·ªá)
  const handleAIMoveEasy = () => {
    if (currentTurn !== aiColor) return; // Ch·ªâ ch·∫°y khi ƒë·∫øn l∆∞·ª£t AI
    console.log("ü§ñ AI ƒëang t√≠nh to√°n n∆∞·ªõc ƒëi...");

    let possibleMoves = [];
    let captureMoves = []; // L∆∞u c√°c n∆∞·ªõc c√≥ th·ªÉ ƒÉn qu√¢n
    let centerMoves = [];  // L∆∞u c√°c n∆∞·ªõc gi√∫p AI ki·ªÉm so√°t b√†n c·ªù

    for (let row = 0; row < 10; row++) {
        for (let col = 0; col < 9; col++) {
            const piece = board[row][col];
            if (piece && ((aiColor === "black" && piece === piece.toUpperCase()) || 
                          (aiColor === "red" && piece === piece.toLowerCase()))) {
                const moves = gameManager.getValidMoves(piece, row, col);
                moves.forEach(([toRow, toCol]) => {
                    const targetPiece = board[toRow][toCol];

                    
                    if ((toRow >= 3 && toRow <= 6) && (toCol >= 3 && toCol <= 5)) {
                        centerMoves.push({ fromRow: row, fromCol: col, toRow, toCol });
                    }
                    else if (targetPiece && targetPiece !== "") {
                        captureMoves.push({ fromRow: row, fromCol: col, toRow, toCol });
                    }
                    // N·∫øu kh√¥ng th√¨ ƒë∆∞a v√†o danh s√°ch n∆∞·ªõc ƒëi th√¥ng th∆∞·ªùng
                    else {
                        possibleMoves.push({ fromRow: row, fromCol: col, toRow, toCol });
                    }
                });
            }
        }
    }

    let chosenMove = null;
    if (captureMoves.length > 0) {
        chosenMove = captureMoves[Math.floor(Math.random() * captureMoves.length)];
        console.log("ü§ñ AI ch·ªçn n∆∞·ªõc ƒëi ƒÇN QU√ÇN:", chosenMove);
    } else if (centerMoves.length > 0) {
        chosenMove = centerMoves[Math.floor(Math.random() * centerMoves.length)];
        console.log("ü§ñ AI ch·ªçn n∆∞·ªõc ƒëi KI·ªÇM SO√ÅT B√ÄN C·ªú:", chosenMove);
    } else if (possibleMoves.length > 0) {
        chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
        console.log("ü§ñ AI ch·ªçn n∆∞·ªõc ƒëi TH√îNG TH∆Ø·ªúNG:", chosenMove);
    }

    if (chosenMove) {
        const newBoard = gameManager.movePiece(chosenMove.fromRow, chosenMove.fromCol, chosenMove.toRow, chosenMove.toCol);
        if (!newBoard) {
            console.error("‚ùå L·ªói: movePiece tr·∫£ v·ªÅ undefined!");
            return;
        }
        setBoard(newBoard);
        setCurrentTurn(playerColor); // Chuy·ªÉn l∆∞·ª£t v·ªÅ ng∆∞·ªùi ch∆°i
    }
};
const handleAIMoveMedium = () => {
    // Ch·ªâ th·ª±c hi·ªán khi ƒë·∫øn l∆∞·ª£t AI
    if (currentTurn !== aiColor) return;

    console.log("ü§ñ AI (Medium) ƒëang t√≠nh to√°n n∆∞·ªõc ƒëi...");

    let possibleMoves = [];
    let captureMoves = [];
    let centerMoves = [];

    for (let row = 0; row < 10; row++) {
        for (let col = 0; col < 9; col++) {
            const piece = board[row][col];
            if (piece && ((aiColor === "black" && piece === piece.toUpperCase()) || 
                          (aiColor === "red" && piece === piece.toLowerCase()))) {
                const moves = gameManager.getValidMoves(piece, row, col);
                moves.forEach(([toRow, toCol]) => {
                    const targetPiece = board[toRow][toCol];

                    // N·∫øu c√≥ th·ªÉ ƒÉn qu√¢n, ∆∞u ti√™n n∆∞·ªõc n√†y
                    if (targetPiece && targetPiece !== "") {
                        captureMoves.push({ fromRow: row, fromCol: col, toRow, toCol });
                    }
                    // N·∫øu di chuy·ªÉn v·ªÅ gi·ªØa b√†n c·ªù (chi·∫øn thu·∫≠t c∆° b·∫£n)
                    else if ((toRow >= 3 && toRow <= 6) && (toCol >= 3 && toCol <= 5)) {
                        centerMoves.push({ fromRow: row, fromCol: col, toRow, toCol });
                    } 
                    // N·∫øu kh√¥ng th√¨ ƒë∆∞a v√†o danh s√°ch n∆∞·ªõc ƒëi th√¥ng th∆∞·ªùng
                    else {
                        possibleMoves.push({ fromRow: row, fromCol: col, toRow, toCol });
                    }
                });
            }
        }
    }

    // ∆Øu ti√™n c√°c n∆∞·ªõc ƒëi ƒÉn qu√¢n ƒë·ªëi th·ªß, sau ƒë√≥ l√† ki·ªÉm so√°t trung t√¢m
    let chosenMove = null;
    if (captureMoves.length > 0) {
        chosenMove = captureMoves[Math.floor(Math.random() * captureMoves.length)];
    } else if (centerMoves.length > 0) {
        chosenMove = centerMoves[Math.floor(Math.random() * centerMoves.length)];
    } else if (possibleMoves.length > 0) {
        chosenMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
    }

    if (chosenMove) {
        const newBoard = gameManager.movePiece(chosenMove.fromRow, chosenMove.fromCol, chosenMove.toRow, chosenMove.toCol);
        setBoard(newBoard);
        setCurrentTurn(playerColor); // ƒê·∫øn l∆∞·ª£t ng∆∞·ªùi ch∆°i
    }
};
const handleAIMoveHard = () => {
    // Ch·ªâ th·ª±c hi·ªán khi ƒë·∫øn l∆∞·ª£t AI
    if (currentTurn !== aiColor) return;

    console.log("ü§ñ AI (Hard) ƒëang t√≠nh to√°n n∆∞·ªõc ƒëi...");

    let possibleMoves = [];
    let bestMove = null;
    let bestMoveScore = -Infinity;

    for (let row = 0; row < 10; row++) {
        for (let col = 0; col < 9; col++) {
            const piece = board[row][col];
            if (piece && ((aiColor === "black" && piece === piece.toUpperCase()) || 
                          (aiColor === "red" && piece === piece.toLowerCase()))) {
                const moves = gameManager.getValidMoves(piece, row, col);
                moves.forEach(([toRow, toCol]) => {
                    const targetPiece = board[toRow][toCol];
                    const moveScore = evaluateMove(board, piece, row, col, toRow, toCol); // H√†m t√≠nh ƒëi·ªÉm n∆∞·ªõc ƒëi

                    if (moveScore > bestMoveScore) {
                        bestMoveScore = moveScore;
                        bestMove = { fromRow: row, fromCol: col, toRow, toCol };
                    }
                });
            }
        }
    }

    if (bestMove) {
        const newBoard = gameManager.movePiece(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol);
        setBoard(newBoard);
        setCurrentTurn(playerColor); // ƒê·∫øn l∆∞·ª£t ng∆∞·ªùi ch∆°i
    }
};

// H√†m t√≠nh ƒëi·ªÉm n∆∞·ªõc ƒëi, c√≥ th·ªÉ s·ª≠ d·ª•ng c√°c chi·∫øn l∆∞·ª£c nh∆∞ ki·ªÉm so√°t b√†n c·ªù, b·∫£o v·ªá qu√¢n c·ªù, ƒÉn qu√¢n ƒë·ªëi th·ªß, ...
const evaluateMove = (board, piece, fromRow, fromCol, toRow, toCol) => {
    // V√≠ d·ª• t√≠nh ƒëi·ªÉm d·ª±a tr√™n vi·ªác ƒÉn qu√¢n v√† ki·ªÉm so√°t b√†n c·ªù
    const targetPiece = board[toRow][toCol];
    let score = 0;

    if (targetPiece) {
        score += 10; // Gi·∫£ s·ª≠ ƒÉn qu√¢n ƒë·ªëi th·ªß c√≥ ƒëi·ªÉm cao
    }

    // Th√™m c√°c ti√™u ch√≠ kh√°c nh∆∞ ki·ªÉm so√°t khu v·ª±c gi·ªØa, b·∫£o v·ªá qu√¢n, v.v.

    return score;
};


  // X·ª≠ l√Ω khi ng∆∞·ªùi ch∆°i ch·ªçn qu√¢n c·ªù ho·∫∑c di chuy·ªÉn
  const handleClick = (row, col) => {
    console.log(`üéØ Clicked position: (${row}, ${col})`);
    console.log("üìå Qu√¢n c·ªù t·∫°i v·ªã tr√≠:", board?.[row]?.[col]);

    // 1Ô∏è‚É£ Ki·ªÉm tra v·ªã tr√≠ c√≥ h·ª£p l·ªá kh√¥ng
    if (row < 0 || row >= 10 || col < 0 || col >= 9) {
        console.warn(`‚ö† V·ªã tr√≠ (${row}, ${col}) ngo√†i ph·∫°m vi b√†n c·ªù!`);
        return;
    }
    if (!board || !board[row] || board[row][col] === undefined) {
        console.warn(`‚ö† D·ªØ li·ªáu qu√¢n c·ªù kh√¥ng h·ª£p l·ªá t·∫°i (${row}, ${col})`);
        return;
    }
    if (currentTurn !== playerColor) return;

    const piece = board[row][col];

    // 2Ô∏è‚É£ N·∫øu ch·ªçn qu√¢n c·ªù h·ª£p l·ªá (c√πng m√†u v·ªõi ng∆∞·ªùi ch∆°i)
    if (piece && ((playerColor === "black" && piece === piece.toUpperCase()) || 
                  (playerColor === "red" && piece === piece.toLowerCase()))) {
        console.log("‚úÖ Qu√¢n c·ªù h·ª£p l·ªá:", piece);
        setSelectedPiece({ row, col });
        const validMoves = gameManager.getValidMoves(piece, row, col);
        setValidMoves(validMoves);
        console.log("üìå N∆∞·ªõc ƒëi h·ª£p l·ªá:", validMoves);
        return;
    }

    // 3Ô∏è‚É£ N·∫øu ƒë√£ ch·ªçn qu√¢n c·ªù v√† b·∫•m v√†o v·ªã tr√≠ h·ª£p l·ªá
    if (selectedPiece) {
        const { row: fromRow, col: fromCol } = selectedPiece;
        console.log("üéØ ƒêang ki·ªÉm tra n∆∞·ªõc ƒëi t·ª´:", fromRow, fromCol, "ƒë·∫øn", row, col);

        // Ki·ªÉm tra n∆∞·ªõc ƒëi c√≥ h·ª£p l·ªá kh√¥ng
        const isValidMove = validMoves.some(([r, c]) => r === row && c === col);
        console.log("üìå Move valid?", isValidMove);

        if (isValidMove) {
            // Th·ª±c hi·ªán di chuy·ªÉn
            const newBoard = gameManager.movePiece(fromRow, fromCol, row, col);
            if (!newBoard) {
                console.error("‚ùå L·ªói: movePiece tr·∫£ v·ªÅ undefined!");
                return;
            }
            setBoard(newBoard);
            setSelectedPiece(null);
            setValidMoves([]);
            setCurrentTurn(aiColor); // ƒê·∫øn l∆∞·ª£t AI

            setTimeout(() => handleAIMove(), 3000); // AI ƒëi sau 0.5s
        } else {
            console.warn("‚ö† N∆∞·ªõc ƒëi kh√¥ng h·ª£p l·ªá!");
            setErrorMessage("N∆∞·ªõc ƒëi kh√¥ng h·ª£p l·ªá!");
            setTimeout(() => setErrorMessage(""), 1500);
        }
    }
};



  const boardSize = 500;
  const cellSize = boardSize / 9;

  return (
    <div className="flex flex-col items-center">
  <h1 className="text-4xl font-bold text-center text-[#003366] mb-2">
    Ch·∫ø ƒë·ªô: {mode.toUpperCase()}
  </h1>
  <h2 className="text-2xl font-semibold text-center text-gray-700 mb-4">
    B·∫°n ch∆°i: {playerColor === "black" ? "‚ôüÔ∏è ƒêen (ƒêi tr∆∞·ªõc)" : "‚ôüÔ∏è ƒê·ªè"}
  </h2>

  <div className="relative w-[500px] h-[550px]">
        <img src="/Assets/chessboard.png" alt="Chessboard" className="w-full h-full" />
        {board.map((row, rowIndex) =>
          row.map((piece, colIndex) =>
            piece ? (
              <img
                key={`${rowIndex}-${colIndex}`}
                src={pieceImages[piece]}
                alt={piece}
                className="absolute w-[45px] h-[45px] transform -translate-x-1/2 -translate-y-1/2 cursor-pointer"
                style={{
                  left: `${colIndex * cellSize + cellSize / 2}px`,
                  top: `${rowIndex * cellSize + cellSize / 2}px`,
                }}
                onClick={() => handleClick(rowIndex, colIndex)}
              />
            ) : null
          )
        )}

        {validMoves.map(([row, col]) => (
          <div
            key={`${row}-${col}`}
            className="absolute w-[45px] h-[45px] bg-green-500 opacity-50 transform -translate-x-1/2 -translate-y-1/2 rounded-full"
            style={{
              left: `${col * cellSize + cellSize / 2}px`,
              top: `${row * cellSize + cellSize / 2}px`,
            }}
            onClick={() => handleClick(row, col)}
          />
        ))}
  </div>
  <button
        onClick={() => navigate("/")} // Quay l·∫°i trang tr∆∞·ªõc
        className="absolute bottom-5 left-5 px-6 py-3 bg-red-500 rounded-full text-lg font-semibold hover:bg-red-700 transition"
      >
        ‚¨Ö Quay l·∫°i
      </button>
</div>

  );
};

export default ChessboardAI;
